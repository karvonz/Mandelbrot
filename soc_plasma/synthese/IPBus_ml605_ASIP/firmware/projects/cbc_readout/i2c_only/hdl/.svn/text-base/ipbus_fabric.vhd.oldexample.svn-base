-- The ipbus bus fabric, address select logic, data multiplexers
--
-- The address table is encoded in ipbus_addr_decode package - no need to change
-- anything here except the number of slaves.
--
-- Ports can be added to give ipbus slaves access to the chip top level.
--
-- Dave Newbold, 2011

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use work.ipbus.ALL;
use work.ipbus_addr_decode.ALL;

entity ipbus_fabric is port(
	ipb_clk, rst : in STD_LOGIC;
	ipb_slave_in : in ipb_wbus;
	ipb_slave_out : out ipb_rbus;
-- Top level ports from here
	cbc_trg, ext_trg, cbc_reset: out std_logic;
	cbc_data: in std_logic
	);

end ipbus_fabric;

architecture rtl of ipbus_fabric is

	constant NSLV: integer := 4;
	signal ipbw: ipb_wbus_array(NSLV-1 downto 0);
	signal ipbr, ipbr_d: ipb_rbus_array(NSLV-1 downto 0);
	signal sel: integer;
	type mux_rdata_t is array(NSLV downto 0) of std_logic_vector(31 downto 0);
	signal mux_rdata: mux_rdata_t;
	signal ored_ack, ored_err: std_logic_vector(NSLV downto 0);
	signal ctrl_reg: std_logic_vector(63 downto 0);

begin

	process(ipb_slave_in.ipb_addr)
	begin
		sel <= ipbus_addr_sel(ipb_slave_in.ipb_addr);
	end process;

	mux_rdata(NSLV) <= (others => '0');
	ored_ack(NSLV) <= '0';
	ored_err(NSLV) <= '0';

	busgen: for i in NSLV-1 downto 0 generate
		signal qual_rdata: std_logic_vector(31 downto 0);
	begin

		ipbw(i).ipb_addr <= ipb_slave_in.ipb_addr;
		ipbw(i).ipb_wdata <= ipb_slave_in.ipb_wdata;
		ipbw(i).ipb_strobe <= ipb_slave_in.ipb_strobe when sel=i else '0';
		ipbw(i).ipb_write <= ipb_slave_in.ipb_write;

--    process(ipb_clk)
--    begin
--      if rising_edge(ipb_clk) then
--        ipbr_d <= ipbr;
--      end if;
--    end process;

		qual_rdata <= ipbr(i).ipb_rdata when sel=i else (others => '0');
		mux_rdata(i) <= qual_rdata or mux_rdata(i+1);
		ored_ack(i) <= ored_ack(i+1) or ipbr(i).ipb_ack;
		ored_err(i) <= ored_err(i+1) or ipbr(i).ipb_err;		

	end generate;

  ipb_slave_out.ipb_rdata <= mux_rdata(0);
  ipb_slave_out.ipb_ack <= ored_ack(0);
  ipb_slave_out.ipb_err <= ored_err(0);

-- Slaves go under here

-- Slave 0: 2x 32b register

	slave0: entity work.ipbus_reg
		generic map(addr_width => 1)
		port map(
			clk => ipb_clk,
			reset => rst,
			ipbus_in => ipbw(0),
			ipbus_out => ipbr(0),
			q => ctrl_reg);

-- Other logic

	cbcstuff: entity work.cbc_logic
		port map(
			clk => ipb_clk,
			cbc_trg => cbc_trg,
			ext_trg => ext_trg,
			go_reg => ctrl_reg(0),
			delay => unsigned(ctrl_reg(39 downto 32)),
			cap_edge => ctrl_reg(44),
			trg_patt => ctrl_reg(42 downto 40));

	cbc_reset <= ctrl_reg(47);

end rtl;


