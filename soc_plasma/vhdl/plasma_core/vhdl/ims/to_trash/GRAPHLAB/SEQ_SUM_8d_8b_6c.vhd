-- This SEQ_SUM_8d_8b_6c file has been generated by the GraphLab tool
-- using the hls_GeneratedMooreArchitecture developped by Bertrand LE GAL
-- and Willy AUBRY for High-Level Synthesis design flow.
-- * Time and Date   : 10:59 10/03/2011
-- * Module name     : 
-- * Module version  : 0
-- * Module command  : 
-- * Author name     : 
-- * E-Mail          : 
-- * Company         : 
-- * Copyright       : 
-- * Design function : 
--
--
--  Correspondence concerning GraphLab software and its modules
--  should be addressed as follows:
--         Bertrand LE GAL (bertrand.legal@ims-bordeaux.fr)
--         Maitre de Conferences - ENSEIRB
--         Laboratoire IMS - ENSEIRB - UMR 5818
--         Universite de Bordeaux 1
--         351, cours de la Liberation
--         F-33405 TALENCE Cedex
--         FRANCE
--
--  Or directly using its website :
--         http://uuu.enseirb.fr/~legal/wp_graphlab



LIBRARY IEEE; 
USE IEEE.STD_LOGIC_1164.ALL; 
USE IEEE.NUMERIC_STD.ALL; 

library ims;
use ims.coprocessor.all;
use ims.conversion.all;

library work; 
use work.all; 
 
ENTITY SEQ_SUM_8d_8b_6c IS 
  PORT ( 
    rst    : IN  STD_LOGIC;
    clock  : IN  STD_LOGIC;
    start  : IN  STD_LOGIC;
    flush  : IN  STD_LOGIC;
    holdn  : IN  STD_LOGIC;
    INPUT_1 : IN STD_LOGIC_VECTOR(31 DOWNTO 0); 
    INPUT_2 : IN STD_LOGIC_VECTOR(31 DOWNTO 0); 
    ready  : OUT  STD_LOGIC;
    nready : OUT  STD_LOGIC;
    icc    : OUT  STD_LOGIC_vector(3  downto 0);
    OUTPUT_1 : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  ); 
END SEQ_SUM_8d_8b_6c; 
 
ARCHITECTURE SEQ_SUM_8d_8b_6c_arch OF SEQ_SUM_8d_8b_6c IS 
COMPONENT ADD_DYNAMIC
  GENERIC(
      C_SIGNED        : NATURAL := 0;
      INPUT_1_WIDTH   : POSITIVE := 16;
      INPUT_2_WIDTH   : POSITIVE := 16;
      OUTPUT_1_WIDTH  : POSITIVE := 16
  );
  PORT( 
       INPUT_1  : IN  STD_LOGIC_VECTOR(INPUT_1_WIDTH -1 DOWNTO 0);
       INPUT_2  : IN  STD_LOGIC_VECTOR(INPUT_2_WIDTH -1 DOWNTO 0);
       OUTPUT_1 : OUT STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
      );
END COMPONENT;
 

   TYPE StateType IS (E0, E1, E2, E3, E4, E5, E6, E7, E8, E9);
   SIGNAL CurrentState_GLOBAL : StateType;

   --
   -- DEFINITION DES REGISTRES 
   --
   SIGNAL OPR_ADD_1_INPUT_1_REGISTER_0001 : STD_LOGIC_VECTOR(10 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0002 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0003 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0004 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0005 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0006 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0007 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0008 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL PORT_9_REGISTER_0009 : STD_LOGIC_VECTOR(10 DOWNTO 0); 
 

   --
   -- DEFINITION DES ENTREES DES REGISTRES (UTILISE POUR LES MULTIPLEXEURS)
   --
   SIGNAL OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT : STD_LOGIC_VECTOR(10 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL PORT_9_REGISTER_0009_INPUT : STD_LOGIC_VECTOR(10 DOWNTO 0); 
 
   SIGNAL OPR_ADD_1_INPUT_1 : STD_LOGIC_VECTOR(10 DOWNTO 0); 
   SIGNAL OPR_ADD_1_INPUT_2 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
   SIGNAL OPR_ADD_1_OUTPUT_1 : STD_LOGIC_VECTOR(10 DOWNTO 0); 
 
BEGIN 
 
   ---------------------------------------------------------  
   --  Cluster name : OPR_ADD_1
   --  * The cluster contains 1 possible execution paths
   --    => The mode 1 required computation(s) : True (E1/E10=>10 states)
   --  
   ---------------------------------------------------------  
   PROC_ASYNC_OPR_ADD_1_INPUT_1 : PROCESS (CurrentState_GLOBAL, OPR_ADD_1_INPUT_1_REGISTER_0001)
   BEGIN
     CASE CurrentState_GLOBAL IS
      -- MODE=1 CYCLE=2 OFFSET=0 => 2
      WHEN E2     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 5 / mode = 1 / cycle = 2)
      -- MODE=1 CYCLE=3 OFFSET=0 => 3
      WHEN E3     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 8 / mode = 1 / cycle = 3)
      -- MODE=1 CYCLE=4 OFFSET=0 => 4
      WHEN E4     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 11 / mode = 1 / cycle = 4)
      -- MODE=1 CYCLE=5 OFFSET=0 => 5
      WHEN E5     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 14 / mode = 1 / cycle = 5)
      -- MODE=1 CYCLE=6 OFFSET=0 => 6
      WHEN E6     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 17 / mode = 1 / cycle = 6)
      -- MODE=1 CYCLE=7 OFFSET=0 => 7
      WHEN E7     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 20 / mode = 1 / cycle = 7)
      -- MODE=1 CYCLE=8 OFFSET=0 => 8
      WHEN E8     => OPR_ADD_1_INPUT_1 <= OPR_ADD_1_INPUT_1_REGISTER_0001;  -- (+ / 23 / mode = 1 / cycle = 8)
      WHEN OTHERS => OPR_ADD_1_INPUT_1 <= (OTHERS=>'X');
     END CASE;
   END PROCESS PROC_ASYNC_OPR_ADD_1_INPUT_1;


   ---------------------------------------------------------  
   --  Cluster name : OPR_ADD_1
   --  * The cluster contains 1 possible execution paths
   --    => The mode 1 required computation(s) : True (E1/E10=>10 states)
   --  
   ---------------------------------------------------------  
   PROC_ASYNC_OPR_ADD_1_INPUT_2 : PROCESS (CurrentState_GLOBAL, OPR_ADD_1_INPUT_2_REGISTER_0002, OPR_ADD_1_INPUT_2_REGISTER_0003, OPR_ADD_1_INPUT_2_REGISTER_0004, OPR_ADD_1_INPUT_2_REGISTER_0005, OPR_ADD_1_INPUT_2_REGISTER_0006, OPR_ADD_1_INPUT_2_REGISTER_0007, OPR_ADD_1_INPUT_2_REGISTER_0008)
   BEGIN
     CASE CurrentState_GLOBAL IS
      -- MODE=1 CYCLE=2 OFFSET=0 => 2
      WHEN E2     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0002;  -- (+ / 5 / mode = 1 / cycle = 2)
      -- MODE=1 CYCLE=3 OFFSET=0 => 3
      WHEN E3     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0003;  -- (+ / 8 / mode = 1 / cycle = 3)
      -- MODE=1 CYCLE=4 OFFSET=0 => 4
      WHEN E4     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0004;  -- (+ / 11 / mode = 1 / cycle = 4)
      -- MODE=1 CYCLE=5 OFFSET=0 => 5
      WHEN E5     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0005;  -- (+ / 14 / mode = 1 / cycle = 5)
      -- MODE=1 CYCLE=6 OFFSET=0 => 6
      WHEN E6     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0006;  -- (+ / 17 / mode = 1 / cycle = 6)
      -- MODE=1 CYCLE=7 OFFSET=0 => 7
      WHEN E7     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0007;  -- (+ / 20 / mode = 1 / cycle = 7)
      -- MODE=1 CYCLE=8 OFFSET=0 => 8
      WHEN E8     => OPR_ADD_1_INPUT_2 <= OPR_ADD_1_INPUT_2_REGISTER_0008;  -- (+ / 23 / mode = 1 / cycle = 8)
      WHEN OTHERS => OPR_ADD_1_INPUT_2 <= (OTHERS=>'X');
     END CASE;
   END PROCESS PROC_ASYNC_OPR_ADD_1_INPUT_2;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_1_REGISTER_0001
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_1_REGISTER_0001 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (a)
        WHEN E2 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp0)
        WHEN E3 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp1)
        WHEN E4 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp2)
        WHEN E5 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp3)
        WHEN E6 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp4)
        WHEN E7 => OPR_ADD_1_INPUT_1_REGISTER_0001 <= OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT; -- mode (1) :: Affectation d'une valeur (temp5)
        WHEN OTHERS => OPR_ADD_1_INPUT_1_REGISTER_0001 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_1_REGISTER_0001;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0002
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0002 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0002 <= OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT; -- mode (1) :: Affectation d'une valeur (b)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0002 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0002;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0003
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0003 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0003 <= OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT; -- mode (1) :: Affectation d'une valeur (c)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0003 <= OPR_ADD_1_INPUT_2_REGISTER_0003; -- mode (1) :: Maintient d'une valeur (c)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0003 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0003;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0004
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0004 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0004 <= OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT; -- mode (1) :: Affectation d'une valeur (d)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0004 <= OPR_ADD_1_INPUT_2_REGISTER_0004; -- mode (1) :: Maintient d'une valeur (d)
        WHEN E3 => OPR_ADD_1_INPUT_2_REGISTER_0004 <= OPR_ADD_1_INPUT_2_REGISTER_0004; -- mode (1) :: Maintient d'une valeur (d)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0004 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0004;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0005
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0005 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0005 <= OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT; -- mode (1) :: Affectation d'une valeur (e)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0005 <= OPR_ADD_1_INPUT_2_REGISTER_0005; -- mode (1) :: Maintient d'une valeur (e)
        WHEN E3 => OPR_ADD_1_INPUT_2_REGISTER_0005 <= OPR_ADD_1_INPUT_2_REGISTER_0005; -- mode (1) :: Maintient d'une valeur (e)
        WHEN E4 => OPR_ADD_1_INPUT_2_REGISTER_0005 <= OPR_ADD_1_INPUT_2_REGISTER_0005; -- mode (1) :: Maintient d'une valeur (e)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0005 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0005;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0006
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0006 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0006 <= OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT; -- mode (1) :: Affectation d'une valeur (f)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0006 <= OPR_ADD_1_INPUT_2_REGISTER_0006; -- mode (1) :: Maintient d'une valeur (f)
        WHEN E3 => OPR_ADD_1_INPUT_2_REGISTER_0006 <= OPR_ADD_1_INPUT_2_REGISTER_0006; -- mode (1) :: Maintient d'une valeur (f)
        WHEN E4 => OPR_ADD_1_INPUT_2_REGISTER_0006 <= OPR_ADD_1_INPUT_2_REGISTER_0006; -- mode (1) :: Maintient d'une valeur (f)
        WHEN E5 => OPR_ADD_1_INPUT_2_REGISTER_0006 <= OPR_ADD_1_INPUT_2_REGISTER_0006; -- mode (1) :: Maintient d'une valeur (f)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0006 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0006;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0007
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0007 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT; -- mode (1) :: Affectation d'une valeur (g)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007; -- mode (1) :: Maintient d'une valeur (g)
        WHEN E3 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007; -- mode (1) :: Maintient d'une valeur (g)
        WHEN E4 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007; -- mode (1) :: Maintient d'une valeur (g)
        WHEN E5 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007; -- mode (1) :: Maintient d'une valeur (g)
        WHEN E6 => OPR_ADD_1_INPUT_2_REGISTER_0007 <= OPR_ADD_1_INPUT_2_REGISTER_0007; -- mode (1) :: Maintient d'une valeur (g)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0007 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0007;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0008
   --
   PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0008 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT; -- mode (1) :: Affectation d'une valeur (h)
        WHEN E2 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN E3 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN E4 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN E5 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN E6 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN E7 => OPR_ADD_1_INPUT_2_REGISTER_0008 <= OPR_ADD_1_INPUT_2_REGISTER_0008; -- mode (1) :: Maintient d'une valeur (h)
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0008 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_OPR_ADD_1_INPUT_2_REGISTER_0008;


   --
   --  PROCESS DEFINED FOR DRIVING COMMAND SIGNALS TO PORT_9_REGISTER_0009
   --
   PROC_REGISTER_CONTROL_PORT_9_REGISTER_0009 : PROCESS (clock)
   BEGIN
      IF ( clock'event AND clock = '1' ) THEN
        CASE CurrentState_GLOBAL IS
        WHEN E8 => PORT_9_REGISTER_0009 <= PORT_9_REGISTER_0009_INPUT; -- mode (1) :: Affectation d'une valeur (z)
        WHEN E9 => PORT_9_REGISTER_0009 <= PORT_9_REGISTER_0009; -- mode (1) :: Maintient d'une valeur (z)
        WHEN OTHERS => PORT_9_REGISTER_0009 <= (OTHERS=>'X');
       END CASE; 
     END IF; -- IF(clock...)
   END PROCESS PROC_REGISTER_CONTROL_PORT_9_REGISTER_0009;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OUTPUT_1(31 downto 0)
   --
   PROCESS (PORT_9_REGISTER_0009)
   BEGIN
      OUTPUT_1(31 downto 0) <= STD_LOGIC_VECTOR( RESIZE( UNSIGNED(PORT_9_REGISTER_0009), 32) );
   END PROCESS;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_1(7 downto 0), OPR_ADD_1_OUTPUT_1)
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= STD_LOGIC_VECTOR( RESIZE( UNSIGNED(INPUT_1(7 downto 0)), 11) );
        WHEN E2 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN E3 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN E4 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN E5 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN E6 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN E7 => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN OTHERS => OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_1_REGISTER_0001_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_1(15 downto 8))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT <= INPUT_1(15 downto 8);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0002_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_1(23 downto 16))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT <= INPUT_1(23 downto 16);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0003_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_1(31 downto 24))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT <= INPUT_1(31 downto 24);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0004_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_2(7 downto 0))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT <= INPUT_2(7 downto 0);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0005_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_2(15 downto 8))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT <= INPUT_2(15 downto 8);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0006_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_2(23 downto 16))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT <= INPUT_2(23 downto 16);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0007_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT
   --
   PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT : PROCESS (CurrentState_GLOBAL, INPUT_2(31 downto 24))
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E1 => OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT <= INPUT_2(31 downto 24);
        WHEN OTHERS => OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_OPR_ADD_1_INPUT_2_REGISTER_0008_INPUT;


   --
   --  PROCESS DEFINED FOR DRIVING SIGNALS TO PORT_9_REGISTER_0009_INPUT
   --
   PROC_MULTIPLEXER_PORT_9_REGISTER_0009_INPUT : PROCESS (CurrentState_GLOBAL, OPR_ADD_1_OUTPUT_1)
   BEGIN
      CASE CurrentState_GLOBAL IS
        WHEN E8 => PORT_9_REGISTER_0009_INPUT <= OPR_ADD_1_OUTPUT_1;
        WHEN OTHERS => PORT_9_REGISTER_0009_INPUT <= (OTHERS=>'X');
      END CASE; 
   END PROCESS PROC_MULTIPLEXER_PORT_9_REGISTER_0009_INPUT;


  	--process(start)
  	--BEGIN 
	--	if (start = '1') then
	--		REPORT "(GL) THE START SIGNAL IS UP !!!";
	--	else
	--		REPORT "(GL) THE START SIGNAL IS DOWN !!!";
	--	end if;
  	--END PROCESS;

   ---------------------------------------------------------  
   PROC_CONTROLER_FSM : PROCESS (clock, rst)
     variable sready  : std_logic;
     variable snready : std_logic;
   BEGIN
    	sready  := '0';
    	snready := '0';

    	IF rst = '0' THEN
       	CurrentState_GLOBAL <= E0;
       	ready       <= sready;
       	nready      <= snready;
			--printmsg("(GL) THE DESIGN IS PROCESSING RESET !");
			
    	ELSIF clock'event and clock = '1' THEN

			--if (start = '1') then
			--	printmsg("(GL) THE START SIGNAL IS UP (3) !!!");
			--end if;

      	IF( flush = '1' ) THEN
        		CurrentState_GLOBAL <= E0;
				--printmsg("(GL) THE DESIGN IS PROCESSING FLUSH !");
      	ELSIF (holdn = '0') AND (CurrentState_GLOBAL /= E0) THEN
        		CurrentState_GLOBAL <= CurrentState_GLOBAL;
				--printmsg("(GL) THE DESIGN IS PROCESSING HOLDN !");
      	ELSE
        		CASE CurrentState_GLOBAL IS
          		WHEN E0   =>
            		IF( start = '1' ) THEN
               		CurrentState_GLOBAL <= E1;
							--REPORT "(GL) THE DESIGN IS STARTING !";
            		ELSE
               		CurrentState_GLOBAL <= E0;
							--REPORT "(GL) THE DESIGN IS WAITING !";
            	END IF;
          	WHEN E1   => CurrentState_GLOBAL <= E2  ;
          	WHEN E2   => CurrentState_GLOBAL <= E3  ;
          	WHEN E3   => CurrentState_GLOBAL <= E4  ;
          	WHEN E4   => CurrentState_GLOBAL <= E5  ;
          	WHEN E5   => CurrentState_GLOBAL <= E6  ;
         	WHEN E6   => CurrentState_GLOBAL <= E7  ;
          	WHEN E7   => CurrentState_GLOBAL <= E8  ;
          	WHEN E8   => CurrentState_GLOBAL <= E9  ;
            	snready := '1'; -- LE CALCUL PRESQUE FINI...
					--printmsg("(GL) SENDING THE READY SIGNAL !");
          	WHEN E9   =>
					--printmsg("(GL) THE COMPUTATION IS FINISHED !");
          		CurrentState_GLOBAL <= E0  ;
          	WHEN OTHERS => 
          	  CurrentState_GLOBAL <= E0;
        		END CASE; 
      	END IF;
      	ready  <= sready;
      	nready <= snready;
    	END IF;
   END PROCESS PROC_CONTROLER_FSM;
   ---------------------------------------------------------  


  icc <= "0000";


OPR_ADD_1 : ADD_DYNAMIC
  GENERIC MAP(
      C_SIGNED         => 0,
      INPUT_1_WIDTH    => 11,
      INPUT_2_WIDTH    => 8,
      OUTPUT_1_WIDTH   => 11
  )
  PORT MAP(
    STD_LOGIC_VECTOR(OPR_ADD_1_INPUT_1),
    STD_LOGIC_VECTOR(OPR_ADD_1_INPUT_2),
    OPR_ADD_1_OUTPUT_1
   );
 

END SEQ_SUM_8d_8b_6c_arch;
